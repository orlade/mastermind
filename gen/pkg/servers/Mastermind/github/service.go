// Code generated by sysl DO NOT EDIT.
package github

import (
	"context"
	"fmt"
	"net/http"
	"net/url"

	"github.com/anz-bank/sysl-go/common"
	"github.com/anz-bank/sysl-go/restlib"
	"github.com/anz-bank/sysl-go/validator"
)

// Service interface for GitHub
type Service interface {
	DeleteReposIssuesCommentsComment_id(ctx context.Context, req *DeleteReposIssuesCommentsComment_idRequest) (*http.Header, error)
	DeleteReposIssuesCommentsComment_idReactionsReaction_id(ctx context.Context, req *DeleteReposIssuesCommentsComment_idReactionsReaction_idRequest) (*http.Header, error)
	DeleteReposIssuesIssue_numberAssignees(ctx context.Context, req *DeleteReposIssuesIssue_numberAssigneesRequest) (*IssueSimple, error)
	DeleteReposIssuesIssue_numberLabels(ctx context.Context, req *DeleteReposIssuesIssue_numberLabelsRequest) (*http.Header, error)
	DeleteReposIssuesIssue_numberLabelsName(ctx context.Context, req *DeleteReposIssuesIssue_numberLabelsNameRequest) (*[]Label, error)
	DeleteReposIssuesIssue_numberLock(ctx context.Context, req *DeleteReposIssuesIssue_numberLockRequest) (*http.Header, error)
	DeleteReposIssuesIssue_numberReactionsReaction_id(ctx context.Context, req *DeleteReposIssuesIssue_numberReactionsReaction_idRequest) (*http.Header, error)
	DeleteReposKeysKey_id(ctx context.Context, req *DeleteReposKeysKey_idRequest) (*http.Header, error)
	DeleteReposLabels(ctx context.Context, req *DeleteReposLabelsRequest) (*http.Header, error)
	GetIssuesList(ctx context.Context, req *GetIssuesListRequest) (*_issues_ok, error)
	GetOrgsIssuesList(ctx context.Context, req *GetOrgsIssuesListRequest) (*_orgs__org__issues_ok, error)
	GetReposIssuesList(ctx context.Context, req *GetReposIssuesListRequest) (*Repos__owner___repo__issues_ok, error)
	GetReposIssuesCommentsList(ctx context.Context, req *GetReposIssuesCommentsListRequest) (*Repos__owner___repo__issues_comments_ok, error)
	GetReposIssuesCommentsComment_id(ctx context.Context, req *GetReposIssuesCommentsComment_idRequest) (*IssueComment, error)
	GetReposIssuesCommentsComment_idReactionsList(ctx context.Context, req *GetReposIssuesCommentsComment_idReactionsListRequest) (*Repos__owner___repo__issues_comments__comment_id__reactions_ok, error)
	GetReposIssuesEventsList(ctx context.Context, req *GetReposIssuesEventsListRequest) (*Repos__owner___repo__issues_events_ok, error)
	GetReposIssuesEventsEvent_id(ctx context.Context, req *GetReposIssuesEventsEvent_idRequest) (*IssueEvent, error)
	GetReposIssuesIssue_number(ctx context.Context, req *GetReposIssuesIssue_numberRequest) (*Issue, error)
	GetReposIssuesIssue_numberCommentsList(ctx context.Context, req *GetReposIssuesIssue_numberCommentsListRequest) (*Repos__owner___repo__issues__issue_number__comments_ok, error)
	GetReposIssuesIssue_numberEventsList(ctx context.Context, req *GetReposIssuesIssue_numberEventsListRequest) (*Repos__owner___repo__issues__issue_number__events_ok, error)
	GetReposIssuesIssue_numberLabelsList(ctx context.Context, req *GetReposIssuesIssue_numberLabelsListRequest) (*Repos__owner___repo__issues__issue_number__labels_ok, error)
	GetReposIssuesIssue_numberReactionsList(ctx context.Context, req *GetReposIssuesIssue_numberReactionsListRequest) (*Repos__owner___repo__issues__issue_number__reactions_ok, error)
	GetReposIssuesIssue_numberTimelineList(ctx context.Context, req *GetReposIssuesIssue_numberTimelineListRequest) (*Repos__owner___repo__issues__issue_number__timeline_ok, error)
	GetReposKeysList(ctx context.Context, req *GetReposKeysListRequest) (*Repos__owner___repo__keys_ok, error)
	GetReposKeysKey_id(ctx context.Context, req *GetReposKeysKey_idRequest) (*DeployKey, error)
	GetReposLabelsList(ctx context.Context, req *GetReposLabelsListRequest) (*Repos__owner___repo__labels_ok, error)
	GetReposLabels(ctx context.Context, req *GetReposLabelsRequest) (*Label, error)
	PatchReposIssuesCommentsComment_id(ctx context.Context, req *PatchReposIssuesCommentsComment_idRequest) (*IssueComment, error)
	PatchReposIssuesIssue_number(ctx context.Context, req *PatchReposIssuesIssue_numberRequest) (*Issue, error)
	PatchReposLabels(ctx context.Context, req *PatchReposLabelsRequest) (*Label, error)
	PostReposIssues(ctx context.Context, req *PostReposIssuesRequest) (*Repos__owner___repo__issues_ok, error)
	PostReposIssuesCommentsComment_idReactions(ctx context.Context, req *PostReposIssuesCommentsComment_idReactionsRequest) (*Reaction, error)
	PostReposIssuesIssue_numberAssignees(ctx context.Context, req *PostReposIssuesIssue_numberAssigneesRequest) (*IssueSimple, error)
	PostReposIssuesIssue_numberComments(ctx context.Context, req *PostReposIssuesIssue_numberCommentsRequest) (*Repos__owner___repo__issues__issue_number__comments_ok, error)
	PostReposIssuesIssue_numberLabels(ctx context.Context, req *PostReposIssuesIssue_numberLabelsRequest) (*[]Label, error)
	PostReposIssuesIssue_numberReactions(ctx context.Context, req *PostReposIssuesIssue_numberReactionsRequest) (*Reaction, error)
	PostReposKeys(ctx context.Context, req *PostReposKeysRequest) (*Repos__owner___repo__keys_ok, error)
	PostReposLabels(ctx context.Context, req *PostReposLabelsRequest) (*Repos__owner___repo__labels_ok, error)
	PutReposIssuesIssue_numberLabels(ctx context.Context, req *PutReposIssuesIssue_numberLabelsRequest) (*[]Label, error)
	PutReposIssuesIssue_numberLock(ctx context.Context, req *PutReposIssuesIssue_numberLockRequest) (*http.Header, error)
}

// Client for GitHub API
type Client struct {
	Client  *http.Client
	URL     string
	Headers map[string][]string
}

// NewClient for GitHub
func NewClient(client *http.Client, serviceURL string) *Client {
	return &Client{client, serviceURL, nil}
}

// DeleteReposIssuesCommentsComment_id ...
func (s *Client) DeleteReposIssuesCommentsComment_id(ctx context.Context, req *DeleteReposIssuesCommentsComment_idRequest) (*http.Header, error) {
	required := []string{}
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v", s.URL, req.Owner, req.Repo, req.Comment_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposIssuesCommentsComment_idReactionsReaction_id ...
func (s *Client) DeleteReposIssuesCommentsComment_idReactionsReaction_id(ctx context.Context, req *DeleteReposIssuesCommentsComment_idReactionsReaction_idRequest) (*http.Header, error) {
	required := []string{}
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v/reactions/%v", s.URL, req.Owner, req.Repo, req.Comment_id, req.Reaction_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposIssuesIssue_numberAssignees ...
func (s *Client) DeleteReposIssuesIssue_numberAssignees(ctx context.Context, req *DeleteReposIssuesIssue_numberAssigneesRequest) (*IssueSimple, error) {
	required := []string{}
	var okResponse IssueSimple
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/assignees", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueSimpleResponse, ok := result.Response.(*IssueSimple)
	if ok {
		valErr := validator.Validate(OkIssueSimpleResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueSimpleResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// DeleteReposIssuesIssue_numberLabels ...
func (s *Client) DeleteReposIssuesIssue_numberLabels(ctx context.Context, req *DeleteReposIssuesIssue_numberLabelsRequest) (*http.Header, error) {
	required := []string{}
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/labels", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposIssuesIssue_numberLabels ...
func (s *Client) DeleteReposIssuesIssue_numberLabelsName(ctx context.Context, req *DeleteReposIssuesIssue_numberLabelsNameRequest) (*[]Label, error) {
	required := []string{}
	var okResponse []Label
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/labels/%v", s.URL, req.Owner, req.Repo, req.Issue_number, req.Name))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkLabelResponse, ok := result.Response.(*[]Label)
	if ok {
		valErr := validator.Validate(OkLabelResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkLabelResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// DeleteReposIssuesIssue_numberLock ...
func (s *Client) DeleteReposIssuesIssue_numberLock(ctx context.Context, req *DeleteReposIssuesIssue_numberLockRequest) (*http.Header, error) {
	required := []string{}
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/lock", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposIssuesIssue_numberReactionsReaction_id ...
func (s *Client) DeleteReposIssuesIssue_numberReactionsReaction_id(ctx context.Context, req *DeleteReposIssuesIssue_numberReactionsReaction_idRequest) (*http.Header, error) {
	required := []string{}
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/reactions/%v", s.URL, req.Owner, req.Repo, req.Issue_number, req.Reaction_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposKeysKey_id ...
func (s *Client) DeleteReposKeysKey_id(ctx context.Context, req *DeleteReposKeysKey_idRequest) (*http.Header, error) {
	required := []string{}
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/keys/%v", s.URL, req.Owner, req.Repo, req.Key_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// DeleteReposLabels ...
func (s *Client) DeleteReposLabels(ctx context.Context, req *DeleteReposLabelsRequest) (*http.Header, error) {
	required := []string{}
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/labels/%v", s.URL, req.Owner, req.Repo, req.Name))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "DELETE",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- DELETE "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}

// GetIssuesList ...
func (s *Client) GetIssuesList(ctx context.Context, req *GetIssuesListRequest) (*_issues_ok, error) {
	required := []string{}
	var okResponse _issues_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/issues", s.URL))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Filter != nil {
		q.Add("filter", *req.Filter)
	}
	if req.State != nil {
		q.Add("state", *req.State)
	}
	if req.Labels != nil {
		q.Add("labels", *req.Labels)
	}
	if req.Sort != nil {
		q.Add("sort", *req.Sort)
	}
	if req.Direction != nil {
		q.Add("direction", *req.Direction)
	}
	if req.Since != nil {
		q.Add("since", *req.Since)
	}
	if req.Collab != nil {
		q.Add("collab", fmt.Sprintf("%v", *req.Collab))
	}
	if req.Orgs != nil {
		q.Add("orgs", fmt.Sprintf("%v", *req.Orgs))
	}
	if req.Owned != nil {
		q.Add("owned", fmt.Sprintf("%v", *req.Owned))
	}
	if req.Pulls != nil {
		q.Add("pulls", fmt.Sprintf("%v", *req.Pulls))
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_issues_okResponse, ok := result.Response.(*_issues_ok)
	if ok {
		valErr := validator.Validate(Ok_issues_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_issues_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetOrgsIssuesList ...
func (s *Client) GetOrgsIssuesList(ctx context.Context, req *GetOrgsIssuesListRequest) (*_orgs__org__issues_ok, error) {
	required := []string{}
	var okResponse _orgs__org__issues_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/orgs/%v/issues", s.URL, req.Org))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Filter != nil {
		q.Add("filter", *req.Filter)
	}
	if req.State != nil {
		q.Add("state", *req.State)
	}
	if req.Labels != nil {
		q.Add("labels", *req.Labels)
	}
	if req.Sort != nil {
		q.Add("sort", *req.Sort)
	}
	if req.Direction != nil {
		q.Add("direction", *req.Direction)
	}
	if req.Since != nil {
		q.Add("since", *req.Since)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_orgs__org__issues_okResponse, ok := result.Response.(*_orgs__org__issues_ok)
	if ok {
		valErr := validator.Validate(Ok_orgs__org__issues_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_orgs__org__issues_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesList ...
func (s *Client) GetReposIssuesList(ctx context.Context, req *GetReposIssuesListRequest) (*Repos__owner___repo__issues_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Milestone != nil {
		q.Add("milestone", *req.Milestone)
	}
	if req.State != nil {
		q.Add("state", *req.State)
	}
	if req.Assignee != nil {
		q.Add("assignee", *req.Assignee)
	}
	if req.Creator != nil {
		q.Add("creator", *req.Creator)
	}
	if req.Mentioned != nil {
		q.Add("mentioned", *req.Mentioned)
	}
	if req.Labels != nil {
		q.Add("labels", *req.Labels)
	}
	if req.Sort != nil {
		q.Add("sort", *req.Sort)
	}
	if req.Direction != nil {
		q.Add("direction", *req.Direction)
	}
	if req.Since != nil {
		q.Add("since", *req.Since)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues_okResponse, ok := result.Response.(*Repos__owner___repo__issues_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesCommentsList ...
func (s *Client) GetReposIssuesCommentsList(ctx context.Context, req *GetReposIssuesCommentsListRequest) (*Repos__owner___repo__issues_comments_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues_comments_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Sort != nil {
		q.Add("sort", *req.Sort)
	}
	if req.Direction != nil {
		q.Add("direction", *req.Direction)
	}
	if req.Since != nil {
		q.Add("since", *req.Since)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues_comments_okResponse, ok := result.Response.(*Repos__owner___repo__issues_comments_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues_comments_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues_comments_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesCommentsComment_id ...
func (s *Client) GetReposIssuesCommentsComment_id(ctx context.Context, req *GetReposIssuesCommentsComment_idRequest) (*IssueComment, error) {
	required := []string{}
	var okResponse IssueComment
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v", s.URL, req.Owner, req.Repo, req.Comment_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueCommentResponse, ok := result.Response.(*IssueComment)
	if ok {
		valErr := validator.Validate(OkIssueCommentResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueCommentResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesCommentsComment_idReactionsList ...
func (s *Client) GetReposIssuesCommentsComment_idReactionsList(ctx context.Context, req *GetReposIssuesCommentsComment_idReactionsListRequest) (*Repos__owner___repo__issues_comments__comment_id__reactions_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues_comments__comment_id__reactions_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v/reactions", s.URL, req.Owner, req.Repo, req.Comment_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Content != nil {
		q.Add("content", *req.Content)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues_comments__comment_id__reactions_okResponse, ok := result.Response.(*Repos__owner___repo__issues_comments__comment_id__reactions_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues_comments__comment_id__reactions_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues_comments__comment_id__reactions_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesEventsList ...
func (s *Client) GetReposIssuesEventsList(ctx context.Context, req *GetReposIssuesEventsListRequest) (*Repos__owner___repo__issues_events_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues_events_ok
	var errorResponse ValidationError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/events", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues_events_okResponse, ok := result.Response.(*Repos__owner___repo__issues_events_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues_events_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues_events_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesEventsEvent_id ...
func (s *Client) GetReposIssuesEventsEvent_id(ctx context.Context, req *GetReposIssuesEventsEvent_idRequest) (*IssueEvent, error) {
	required := []string{}
	var okResponse IssueEvent
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/events/%v", s.URL, req.Owner, req.Repo, req.Event_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueEventResponse, ok := result.Response.(*IssueEvent)
	if ok {
		valErr := validator.Validate(OkIssueEventResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueEventResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_number ...
func (s *Client) GetReposIssuesIssue_number(ctx context.Context, req *GetReposIssuesIssue_numberRequest) (*Issue, error) {
	required := []string{}
	var okResponse Issue
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueResponse, ok := result.Response.(*Issue)
	if ok {
		valErr := validator.Validate(OkIssueResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_numberCommentsList ...
func (s *Client) GetReposIssuesIssue_numberCommentsList(ctx context.Context, req *GetReposIssuesIssue_numberCommentsListRequest) (*Repos__owner___repo__issues__issue_number__comments_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__comments_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/comments", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Since != nil {
		q.Add("since", *req.Since)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__comments_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__comments_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__comments_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__comments_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_numberEventsList ...
func (s *Client) GetReposIssuesIssue_numberEventsList(ctx context.Context, req *GetReposIssuesIssue_numberEventsListRequest) (*Repos__owner___repo__issues__issue_number__events_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__events_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/events", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__events_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__events_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__events_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__events_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_numberLabelsList ...
func (s *Client) GetReposIssuesIssue_numberLabelsList(ctx context.Context, req *GetReposIssuesIssue_numberLabelsListRequest) (*Repos__owner___repo__issues__issue_number__labels_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__labels_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/labels", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__labels_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__labels_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__labels_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__labels_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_numberReactionsList ...
func (s *Client) GetReposIssuesIssue_numberReactionsList(ctx context.Context, req *GetReposIssuesIssue_numberReactionsListRequest) (*Repos__owner___repo__issues__issue_number__reactions_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__reactions_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/reactions", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Content != nil {
		q.Add("content", *req.Content)
	}
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__reactions_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__reactions_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__reactions_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__reactions_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposIssuesIssue_numberTimelineList ...
func (s *Client) GetReposIssuesIssue_numberTimelineList(ctx context.Context, req *GetReposIssuesIssue_numberTimelineListRequest) (*Repos__owner___repo__issues__issue_number__timeline_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__timeline_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/timeline", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__timeline_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__timeline_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__timeline_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__timeline_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposKeysList ...
func (s *Client) GetReposKeysList(ctx context.Context, req *GetReposKeysListRequest) (*Repos__owner___repo__keys_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__keys_ok
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/keys", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__keys_okResponse, ok := result.Response.(*Repos__owner___repo__keys_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__keys_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__keys_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposKeysKey_id ...
func (s *Client) GetReposKeysKey_id(ctx context.Context, req *GetReposKeysKey_idRequest) (*DeployKey, error) {
	required := []string{}
	var okResponse DeployKey
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/keys/%v", s.URL, req.Owner, req.Repo, req.Key_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkDeployKeyResponse, ok := result.Response.(*DeployKey)
	if ok {
		valErr := validator.Validate(OkDeployKeyResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkDeployKeyResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposLabelsList ...
func (s *Client) GetReposLabelsList(ctx context.Context, req *GetReposLabelsListRequest) (*Repos__owner___repo__labels_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__labels_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/labels", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	q := u.Query()
	if req.Per_page != nil {
		q.Add("per_page", fmt.Sprintf("%v", *req.Per_page))
	}
	if req.Page != nil {
		q.Add("page", fmt.Sprintf("%v", *req.Page))
	}
	u.RawQuery = q.Encode()
	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__labels_okResponse, ok := result.Response.(*Repos__owner___repo__labels_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__labels_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__labels_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// GetReposLabels ...
func (s *Client) GetReposLabels(ctx context.Context, req *GetReposLabelsRequest) (*Label, error) {
	required := []string{}
	var okResponse Label
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/labels/%v", s.URL, req.Owner, req.Repo, req.Name))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "GET",
		URLString:     u.String(),
		Body:          nil,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- GET "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkLabelResponse, ok := result.Response.(*Label)
	if ok {
		valErr := validator.Validate(OkLabelResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkLabelResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PatchReposIssuesCommentsComment_id ...
func (s *Client) PatchReposIssuesCommentsComment_id(ctx context.Context, req *PatchReposIssuesCommentsComment_idRequest) (*IssueComment, error) {
	required := []string{}
	var okResponse IssueComment
	var errorResponse ValidationError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v", s.URL, req.Owner, req.Repo, req.Comment_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "PATCH",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- PATCH "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueCommentResponse, ok := result.Response.(*IssueComment)
	if ok {
		valErr := validator.Validate(OkIssueCommentResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueCommentResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PatchReposIssuesIssue_number ...
func (s *Client) PatchReposIssuesIssue_number(ctx context.Context, req *PatchReposIssuesIssue_numberRequest) (*Issue, error) {
	required := []string{}
	var okResponse Issue
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "PATCH",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- PATCH "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueResponse, ok := result.Response.(*Issue)
	if ok {
		valErr := validator.Validate(OkIssueResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PatchReposLabels ...
func (s *Client) PatchReposLabels(ctx context.Context, req *PatchReposLabelsRequest) (*Label, error) {
	required := []string{}
	var okResponse Label
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/labels/%v", s.URL, req.Owner, req.Repo, req.Name))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "PATCH",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- PATCH "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkLabelResponse, ok := result.Response.(*Label)
	if ok {
		valErr := validator.Validate(OkLabelResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkLabelResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssues ...
func (s *Client) PostReposIssues(ctx context.Context, req *PostReposIssuesRequest) (*Repos__owner___repo__issues_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues_okResponse, ok := result.Response.(*Repos__owner___repo__issues_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssuesCommentsComment_idReactions ...
func (s *Client) PostReposIssuesCommentsComment_idReactions(ctx context.Context, req *PostReposIssuesCommentsComment_idReactionsRequest) (*Reaction, error) {
	required := []string{}
	var okResponse Reaction
	var errorResponse Object
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/comments/%v/reactions", s.URL, req.Owner, req.Repo, req.Comment_id))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkReactionResponse, ok := result.Response.(*Reaction)
	if ok {
		valErr := validator.Validate(OkReactionResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkReactionResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssuesIssue_numberAssignees ...
func (s *Client) PostReposIssuesIssue_numberAssignees(ctx context.Context, req *PostReposIssuesIssue_numberAssigneesRequest) (*IssueSimple, error) {
	required := []string{}
	var okResponse IssueSimple
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/assignees", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: nil,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkIssueSimpleResponse, ok := result.Response.(*IssueSimple)
	if ok {
		valErr := validator.Validate(OkIssueSimpleResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkIssueSimpleResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssuesIssue_numberComments ...
func (s *Client) PostReposIssuesIssue_numberComments(ctx context.Context, req *PostReposIssuesIssue_numberCommentsRequest) (*Repos__owner___repo__issues__issue_number__comments_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__issues__issue_number__comments_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/comments", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__issues__issue_number__comments_okResponse, ok := result.Response.(*Repos__owner___repo__issues__issue_number__comments_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__issues__issue_number__comments_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__issues__issue_number__comments_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssuesIssue_numberLabels ...
func (s *Client) PostReposIssuesIssue_numberLabels(ctx context.Context, req *PostReposIssuesIssue_numberLabelsRequest) (*[]Label, error) {
	required := []string{}
	var okResponse []Label
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/labels", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkLabelResponse, ok := result.Response.(*[]Label)
	if ok {
		valErr := validator.Validate(OkLabelResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkLabelResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposIssuesIssue_numberReactions ...
func (s *Client) PostReposIssuesIssue_numberReactions(ctx context.Context, req *PostReposIssuesIssue_numberReactionsRequest) (*Reaction, error) {
	required := []string{}
	var okResponse Reaction
	var errorResponse Object
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/reactions", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkReactionResponse, ok := result.Response.(*Reaction)
	if ok {
		valErr := validator.Validate(OkReactionResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkReactionResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposKeys ...
func (s *Client) PostReposKeys(ctx context.Context, req *PostReposKeysRequest) (*Repos__owner___repo__keys_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__keys_ok
	var errorResponse ValidationError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/keys", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__keys_okResponse, ok := result.Response.(*Repos__owner___repo__keys_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__keys_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__keys_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PostReposLabels ...
func (s *Client) PostReposLabels(ctx context.Context, req *PostReposLabelsRequest) (*Repos__owner___repo__labels_ok, error) {
	required := []string{}
	var okResponse Repos__owner___repo__labels_ok
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/labels", s.URL, req.Owner, req.Repo))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "POST",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- POST "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	Ok_repos__owner___repo__labels_okResponse, ok := result.Response.(*Repos__owner___repo__labels_ok)
	if ok {
		valErr := validator.Validate(Ok_repos__owner___repo__labels_okResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return Ok_repos__owner___repo__labels_okResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PutReposIssuesIssue_numberLabels ...
func (s *Client) PutReposIssuesIssue_numberLabels(ctx context.Context, req *PutReposIssuesIssue_numberLabelsRequest) (*[]Label, error) {
	required := []string{}
	var okResponse []Label
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/labels", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "PUT",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    &okResponse,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- PUT "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	OkLabelResponse, ok := result.Response.(*[]Label)
	if ok {
		valErr := validator.Validate(OkLabelResponse)
		if valErr != nil {
			return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, valErr)
		}

		return OkLabelResponse, nil
	}
	return nil, common.CreateDownstreamError(ctx, common.DownstreamUnexpectedResponseError, result.HTTPResponse, result.Body, nil)
}

// PutReposIssuesIssue_numberLock ...
func (s *Client) PutReposIssuesIssue_numberLock(ctx context.Context, req *PutReposIssuesIssue_numberLockRequest) (*http.Header, error) {
	required := []string{}
	var errorResponse BasicError
	u, err := url.Parse(fmt.Sprintf("%s/repos/%v/%v/issues/%v/lock", s.URL, req.Owner, req.Repo, req.Issue_number))
	if err != nil {
		return nil, common.CreateError(ctx, common.InternalError, "failed to parse url", err)
	}

	result, err := restlib.DoHTTPRequest2(ctx, &restlib.HTTPRequest{
		Client:        s.Client,
		Method:        "PUT",
		URLString:     u.String(),
		Body:          req.Request,
		Required:      required,
		OKResponse:    nil,
		ErrorResponse: &errorResponse,
		ExtraHeaders:  nil,
	})
	restlib.OnRestResultHTTPResult(ctx, result, err)
	if err != nil {
		response, ok := err.(*restlib.HTTPResult)
		if !ok {
			return nil, common.CreateError(ctx, common.DownstreamUnavailableError, "call failed: GitHub <- PUT "+u.String(), err)
		}
		return nil, common.CreateDownstreamError(ctx, common.DownstreamResponseError, response.HTTPResponse, response.Body, &errorResponse)
	}

	if result.HTTPResponse.StatusCode == http.StatusUnauthorized {
		return nil, common.CreateDownstreamError(ctx, common.DownstreamUnauthorizedError, result.HTTPResponse, result.Body, nil)
	}
	return &result.HTTPResponse.Header, nil
}
